<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Playlist Editor</title>
	<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="IPTV ds" />
<link rel="manifest" href="/site.webmanifest" />

    <script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>



<style>


/* ... other styles ... */
        th:first-child,
        td:first-child {
            width: 30px;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            text-align: center;
        }
        th:nth-child(2), /* # column */
        td:nth-child(2) {
            width: 50px;
            text-align: center;
        }
        th:nth-child(3), /* Play button column */
        td:nth-child(3) {
            width: 50px;
            text-align: center;
        }
        .logo-cell {
            width: 70px; /* Slightly reduced from before */
        }
        .logo-img {
            max-width: 85%; /* Reduce size by 15% */
            height: auto;
            object-fit: contain;
            background-color: transparent;
            max-height: 25px; /* Adjust if needed based on the 15% reduction */
        }
        .name-cell {
            width: 400px; /* Approximately 50 characters - adjust if needed */
            word-break: break-word;
        }
        .group-cell {
            width: 400px; /* Approximately 50 characters - adjust if needed */
            word-break: break-word;
        }
        th:nth-child(7), /* Country column */
        td:nth-child(7) {
            width: 60px;
            text-align: center;
        }
        th:last-child, /* Copy URL column */
        td:last-child {
            width: 80px;
            text-align: center;
        }
        .hidden {
            display: none;
        }
        body {
            background-color: #d1d5db;
        }
        .bg-white {
            background-color: #d1d5db !important;
        }
        #playlist-table-body tr {
            padding-top: 0.1rem;
            padding-bottom: 0.1rem;
        }
.sticky-header {
            position: sticky;
            top: 0;
            background-color: #f3f4f6;
            z-index: 10;
            padding: 0.5rem;
            text-align: left;
        }
        .sticky-buttons {
            position: sticky;
            top: 3rem; /* Adjust top value if needed to avoid overlap */
            background-color: #e5e7eb;
            z-index: 9;
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            text-align: left;
        }
		
		.played-permanently {
    background-color: rgba(128, 0, 128, 0.1) !important;
}

.selected-row {
    background-color: rgba(255, 255, 0, 0.3) !important; /* Light yellow */
}

.editing-row {
    background-color: rgba(0, 255, 0, 0.2) !important; /* Light green */
}


    </style>

</head>
<body class="bg-gray-300 font-sans">

<div class="sticky-header p-2 shadow-md">
      <div class="flex justify-between items-center text-sm">
         <div>
            Total: <span id="total-channels">0</span> |
            Selected: <span id="selected-channels">0</span> |
            Deleted: <span id="deleted-channels">0</span> |
            File: <span id="current-file">None</span>
         </div>
         <div>
	<button onclick="document.getElementById('convertM3U').click()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-2 rounded text-xs">M3U ➜ XLSX</button>
<button onclick="document.getElementById('convertXLSX').click()" class="bg-green-500 hover:bg-green-700 text-white font-bold py-1 px-2 rounded text-xs">XLSX ➜ M3U</button>
<input type="file" id="convertM3U" class="hidden" accept=".m3u" onchange="handleM3UtoXLSX(this.files[0])">
<input type="file" id="convertXLSX" class="hidden" accept=".xlsx" onchange="handleXLSXtoM3U(this.files[0])">
        </div>
      </div>
   </div>

 <div class="sticky-buttons p-2 flex space-x-2 shadow-sm">
    <input type="file" id="file-input" class="hidden" accept=".m3u,.xlsx">
    <button id="load-button" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded text-sm">Load</button>
    <input type="text" id="search-input" placeholder="Search channel name" class="shadow appearance-none border rounded w-auto py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-sm">
    <input type="text" id="group-filter-input" placeholder="Filter by group" class="shadow appearance-none border rounded w-auto py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-sm">
    <button id="undo-button" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded text-sm">Undo</button>
    <button id="delete-selected-button" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm">Delete Selected</button>
    <button id="duplicates-button" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded text-sm">Duplicates</button>
    <button id="export-m3u-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded text-sm">Export M3U</button>
  </div>


    <div class="p-4">
        <table class="shadow-md rounded w-full bg-white">
            <thead class="bg-gray-200">
                <tr>
                    <th class="py-2 px-3"><input type="checkbox" id="select-all"></th>
                    <th class="py-2 px-3 text-left">#</th>
                    <th class="py-2 px-3 text-left">▶</th>
                    <th class="py-2 px-3 text-left">Logo</th>
                    <th class="py-2 px-3 text-left">Name</th>
                    <th class="py-2 px-3 text-left">Group</th>
                    <th class="py-2 px-3 text-left">Country</th>
                    <th class="py-2 px-3 text-left">URL</th>
                </tr>
            </thead>
            <tbody id="playlist-table-body">
                </tbody>
        </table>
    </div>
    
	<script>
        const fileInput = document.getElementById('file-input');
        const loadButton = document.getElementById('load-button');
        const xlsxToM3uButton = document.getElementById('xlsx-to-m3u');
        const searchInput = document.getElementById('search-input');
		const groupFilterInput = document.getElementById('group-filter-input');
        const saveButton = document.getElementById('save-button');
		const undoButton = document.getElementById('undo-button'); // Ensure you have this at the top of your script
        const deleteSelectedButton = document.getElementById('delete-selected-button');
        const duplicatesButton = document.getElementById('duplicates-button');
        const exportM3uButton = document.getElementById('export-m3u-button');
        const selectAllCheckbox = document.getElementById('select-all');
        const playlistTableBody = document.getElementById('playlist-table-body');
        const totalChannelsSpan = document.getElementById('total-channels');
        const selectedChannelsSpan = document.getElementById('selected-channels');
        const deletedChannelsSpan = document.getElementById('deleted-channels');
        const currentFileSpan = document.getElementById('current-file');
		const onlySelectedCheckbox = document.getElementById('only-selected-checkbox');

        let allChannels = [];
        let visibleChannels = [];
        let deletedChannels = [];
        let history = [];
        let currentFile = null;
		let channelHistory = [];

        // --- Utility Functions ---

function triggerM3UtoXLSX() {
    document.getElementById('convertM3U').click();
}

function triggerXLSXtoM3U() {
    document.getElementById('convertXLSX').click();
}

function handleM3UtoXLSX(file) {
    const reader = new FileReader();
    reader.onload = function (event) {
        const lines = event.target.result.split(/\r?\n/);
        const data = [["Name", "Group", "Logo", "tvg-id", "URL"]];
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].startsWith("#EXTINF")) {
                const info = lines[i];
		const url = lines[i + 1] || "";
                const name = (info.match(/,(.*)$/) || [])[1] || "Unknown";
                const logo = (info.match(/tvg-logo=\"(.*?)\"/) || [])[1] || "";
                const group = (info.match(/group-title=\"(.*?)\"/) || [])[1] || "";
                const tvgid = (info.match(/tvg-id=\"(.*?)\"/) || [])[1] || "";
                data.push([name, group, logo, tvgid, url]);
                i++;
            }
        }
        const ws = XLSX.utils.aoa_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Playlist");
        const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([new Uint8Array(excelBuffer)], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });
        const filename = file.name.replace(/\.[^/.]+$/, "") + "_" + Date.now() + ".xlsx";
        downloadFile(blob, filename, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8');
    };
    reader.readAsText(file);
}

function handleXLSXtoM3U(file) {
    const reader = new FileReader();
    reader.onload = function (event) {
        const data = new Uint8Array(event.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        const [header, ...entries] = rows;
        const m3u = ["#EXTM3U"];
        for (let i = 0; i < entries.length; i++) {
            const row = entries[i];
            const name = row[0] || "";
            const group = row[1] || "";
            const logo = row[2] || "";
            const tvgid = row[3] || "";
            const url = row[4] || "";
            m3u.push(`#EXTINF:-1 tvg-id="${tvgid}" tvg-logo="${logo}" group-title="${group}",${name}`);
            m3u.push(url);
        }
        const m3uContent = m3u.join("\n");
        const filename = file.name.replace(/\.[^/.]+$/, "") + "_" + Date.now() + ".m3u";
        downloadFile(m3uContent, filename, 'text/plain;charset=utf-8');
    };
    reader.readAsArrayBuffer(file);
}

	function getUniqueGroups(channels) {
    const groups = new Set();
    channels.forEach(channel => {
        if (channel.groupTitle) {
            groups.add(channel.groupTitle);
        }
    });
    return Array.from(groups).sort(); // Return as a sorted array
}

	function generateFilename(ext) {
            return `${currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") : 'playlist'}.${ext}`;
        }

        function updateStatus() {
            totalChannelsSpan.textContent = allChannels.length;
            selectedChannelsSpan.textContent = allChannels.filter(channel => channel.selected).length;
            deletedChannelsSpan.textContent = deletedChannels.length;
            currentFileSpan.textContent = currentFile ? currentFile.name : 'None';
        }

 function saveState() {
        history.push({
            allChannels: JSON.parse(JSON.stringify(allChannels)),
            deletedChannels: [...deletedChannels]
        });
        console.log("State saved. History length:", history.length); // Added log
        // Optionally, you might want to limit the history size
        if (history.length > 10) {
            history.shift();
            console.log("History shifted. New length:", history.length); // Added log
        }
    }


    function restoreState() {
        console.log("Undo button clicked. Current history length:", history.length);
        if (history.length > 1) {
            // Indicate waiting state immediately
            undoButton.textContent = "WAIT...";
            undoButton.classList.add('bg-black');
            undoButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');

            setTimeout(() => { // Delay the actual undo operation
                const previousState = history.pop();
                allChannels = previousState.allChannels;
                deletedChannels = previousState.deletedChannels;

                // Re-apply filter values (as before)
                const searchInput = document.getElementById('search-input');
                const currentSearchTerm = searchInput ? searchInput.value : '';
                const groupFilterInput = document.getElementById('group-filter-input');
                const currentGroupTerm = groupFilterInput ? groupFilterInput.value : '';
                if (searchInput) searchInput.value = currentSearchTerm;
                if (groupFilterInput) groupFilterInput.value = currentGroupTerm;

                applyFilters();
                renderTable(visibleChannels);
                updateStatus();

    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
	
                // Revert button appearance after action
                setTimeout(() => {
                    undoButton.textContent = "Undo";
                    undoButton.classList.remove('bg-black');
                    undoButton.classList.add('bg-yellow-500');
                    undoButton.classList.add('hover:bg-yellow-700');
                }, 100); // Small delay for reverting
                console.log("State restored. History length:", history.length);
            }, 0); // Delay of 0 to push to the end of the event loop
        } else {
            alert("No previous state to undo.");
            console.log("No previous state to undo.");
        }
    }
	

      function filterChannels() {
          const searchTerm = searchInput.value.toLowerCase();
          visibleChannels = allChannels.filter(channel => channel.name.toLowerCase().includes(searchTerm));
          renderTable(visibleChannels);
		 
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
      }

      function applyFilters() {
          const searchTerm = searchInput.value.toLowerCase();
          const groupTerm = groupFilterInput.value.toLowerCase();
          
          visibleChannels = allChannels.filter(channel => {
              const nameMatch = channel.name.toLowerCase().includes(searchTerm);
              const groupMatch = channel.groupTitle.toLowerCase().includes(groupTerm);
			const selectedMatch = channel.selected; // Now, selectedMatch is simply the channel's selected state
			return nameMatch && groupMatch;        // Only filter by name and group
          });
          renderTable(visibleChannels);
          updateStatus();
		
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
      }

	let showingDuplicates = false;
duplicatesButton.addEventListener('click', () => {
    showingDuplicates = !showingDuplicates;
    if (showingDuplicates) {
        findDuplicateUrls();
        duplicatesButton.textContent = 'Show All';
    } else {
        visibleChannels = []; // Clear the visible channels
        allChannels.forEach(channel => visibleChannels.push(channel)); // Repopulate
        playlistTableBody.innerHTML = ''; // Clear the table body
        renderTable(visibleChannels);      // Render the full list again
		
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
        duplicatesButton.textContent = 'Duplicates';
    }
});


        function findDuplicateUrls() {
            const urlCounts = {};
            allChannels.forEach(channel => {
                urlCounts[channel.url] = (urlCounts[channel.url] || 0) + 1;
            });
            visibleChannels = allChannels.filter(channel => urlCounts[channel.url] > 1);
            renderTable(visibleChannels);
			
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
        }

        // --- M3U File Handling ---

function parseM3U(fileContent) {
            const lines = fileContent.split('\n').filter(line => line.trim() !== '');
            const channels = [];
            let currentChannel = null;
            lines.forEach(line => {
                if (line.startsWith('#EXTINF:')) {
                    currentChannel = {
                        tvgId: '',
                        groupTitle: '',
                        tvgLogo: '',
                        name: '',
                        url: '',
                        selected: false,
                        played: false
                    };
                    const parts = line.match(/#EXTINF:-1\s+(.*?),?(.*)?/);
                    if (parts && parts[1]) {
                        const attributesString = parts[1];
                        const nameAfterComma = parts[2] ? parts[2].trim() : '';

                        // Try to match attributes in the first format (tvg-chno first)
                        let match = attributesString.match(/tvg-chno="([^"]*)"\s+tvg-id="([^"]*)"\s+tvg-name="([^"]*)"\s+tvg-logo="([^"]*)"\s+group-title="([^"]*)"/);
                        if (match) {
                            currentChannel.tvgId = match[2] || '';
                            currentChannel.name = match[3] ? match[3].trim() : '';
                            currentChannel.tvgLogo = match[4] || '';
                            currentChannel.groupTitle = match[5] || '';
                            if (nameAfterComma) currentChannel.name = nameAfterComma;
                        } else {
                            // Try to match attributes in the second format (order doesn't matter as much here)
                            const tvgIdMatch = attributesString.match(/tvg-id="([^"]*)"/);
                            if (tvgIdMatch) currentChannel.tvgId = tvgIdMatch[1];

                            const tvgLogoMatch = attributesString.match(/tvg-logo="([^"]*)"/);
                            if (tvgLogoMatch) currentChannel.tvgLogo = tvgLogoMatch[1];

                            const groupTitleMatch = attributesString.match(/group-title="([^"]*)"/);
                            if (groupTitleMatch) currentChannel.groupTitle = groupTitleMatch[1];

                            const tvgNameMatch = attributesString.match(/tvg-name="([^"]*)"/);
                            if (tvgNameMatch && !currentChannel.name) currentChannel.name = tvgNameMatch[1];

                            if (nameAfterComma) currentChannel.name = nameAfterComma;
                        }
                    } else {
                        const simpleInfo = line.match(/#EXTINF:-1(?:,(.*))?/);
                        if (simpleInfo) {
                            currentChannel.name = simpleInfo[1] ? simpleInfo[1].trim() : '';
                        }
                    }
                } else if (currentChannel && line.startsWith('http')) {
                    currentChannel.url = line.trim();
                    channels.push(currentChannel);
                    currentChannel = null;
                }
            });
            return channels;
        }


function exportM3UContent(channels) {
        let m3uContent = "#EXTM3U\n";
        channels.forEach(channel => { // Using the 'channels' argument
            let extinfLine = `#EXTINF:-1 tvg-logo="${channel.tvgLogo}"`;
            if (channel.tvgId) {
                extinfLine += ` tvg-id="${channel.tvgId}"`;
            }
            if (channel.groupTitle) {
                extinfLine += ` group-title="${channel.groupTitle}"`; // Accessing groupTitle
            }
            extinfLine += `,${channel.name}\n${channel.url}\n`; // Accessing name
            m3uContent += extinfLine;
        });
        return m3uContent; // Return the generated content
    }

    function exportM3U() {
        const m3uContent = exportM3UContent(allChannels); // Call the content generation function
        const filename = currentFile ? currentFile.name.replace('.m3u', '_edited.m3u') : 'edited_playlist.m3u';
        const blob = new Blob([m3uContent], { type: 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

        function downloadFile(content, filename, contentType) {
            const a = document.createElement('a');
            const file = new Blob([content], { type: contentType });
            a.href = URL.createObjectURL(file);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        // --- XLSX File Handling (Basic Structure - Requires a Library like SheetJS) ---
        // Placeholder functions - you'd need to integrate a library for actual XLSX processing
        function parseXLSX(file) {
            alert("XLSX parsing not fully implemented in this basic version. You'd need to integrate a library like SheetJS.");
            return [];
        }

        function exportXLSXContent(channels) {
            alert("XLSX exporting not fully implemented in this basic version. You'd need to integrate a library like SheetJS.");
            return "";
        }

        // --- Rendering the Table ---
function renderTable(channels) {
    playlistTableBody.innerHTML = '';
    channels.forEach((channel, currentIndex) => {
        const originalIndex = allChannels.indexOf(channel);
        const row = playlistTableBody.insertRow();
        row.classList.add('hover:bg-gray-100');
        if (channel.selected) row.classList.add('selected-row'); // Applying the class
        if (channel.isEditing) row.classList.add('editing-row');
        if (channel.played) row.classList.add('played-row');
		if (channel.playedPermanently) row.classList.add('played-permanently');

        const selectCell = row.insertCell();
        selectCell.classList.add('py-2', 'px-3');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.classList.add('row-select');
        checkbox.checked = channel.selected;
		checkbox.addEventListener('change', () => {
            channel.selected = checkbox.checked;
            row.classList.toggle('selected-row', channel.selected); // Toggling the class
            updateStatus();
        });
        selectCell.appendChild(checkbox);

        const numberCell = row.insertCell();
        numberCell.classList.add('py-2', 'px-3', 'channel-number', 'number-cell', 'cursor-pointer');
        numberCell.textContent = originalIndex + 1;
       
	numberCell.addEventListener('click', () => {
            const moveBefore = prompt(`Move channel #${originalIndex + 1} before channel # (enter number):`);
            if (moveBefore !== null && moveBefore.trim() !== '') {
                const targetIndex = parseInt(moveBefore) - 1;
                if (!isNaN(targetIndex) && targetIndex >= 0 && targetIndex < allChannels.length && targetIndex !== originalIndex) {
                    saveState();

                    // Indicate waiting state immediately
                    undoButton.textContent = "WAIT...";
                    undoButton.classList.add('bg-black');
                    undoButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');

                    setTimeout(() => { // Delay the reordering and rendering
                        const channelToMove = allChannels[originalIndex];
                        allChannels.splice(originalIndex, 1);
                        allChannels.splice(targetIndex, 0, channelToMove);

                        applyFilters();
                        renderTable(visibleChannels);
					
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }

                        // Revert button appearance after action
                        setTimeout(() => {
                            undoButton.textContent = "Undo";
                            undoButton.classList.remove('bg-black');
                            undoButton.classList.add('bg-yellow-500');
                            undoButton.classList.add('hover:bg-yellow-700');
                        }, 100); // Small delay
                    }, 0); // Delay of 0
                } else if (targetIndex === originalIndex) {
                    alert("You entered the current channel number. No change needed.");
                } else {
                    alert("Invalid channel number entered.");
                }
            }
        });
		
        const playCell = row.insertCell();
        playCell.classList.add('py-2', 'px-3', 'play-cell');
		
        const playButton = document.createElement('button');
        playButton.textContent = '▶';
        playButton.classList.add('bg-indigo-500', 'hover:bg-indigo-700', 'text-white', 'font-bold', 'py-1', 'px-2', 'rounded', 'text-xs');
        playButton.addEventListener('click', () => {
            const m3uContent = `#EXTM3U\n#EXTINF:-1,${channel.name}\n${channel.url}`;
            const blob = new Blob([m3uContent], { type: 'application/vnd.apple.mpegurl' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${channel.name.replace(/[^a-zA-Z0-9]/g, '_')}.m3u`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            channel.played = true;
            row.classList.add('played-row');
			channel.playedPermanently = true;
        row.classList.add('played-permanently');
        });
        playCell.appendChild(playButton);

        const logoCell = row.insertCell();
        logoCell.classList.add('py-2', 'px-3', 'logo-cell');
        const logoImg = document.createElement('img');
        logoImg.src = channel.tvgLogo || 'placeholder.png';
        logoImg.alt = 'Logo';
        logoImg.classList.add('logo-img');
        logoCell.appendChild(logoImg);
        logoImg.addEventListener('click', () => {
            const newLogoUrl = prompt("Enter new logo URL:", channel.tvgLogo);
            if (newLogoUrl !== null) {
                saveState();
                channel.tvgLogo = newLogoUrl;
                logoImg.src = newLogoUrl;
            }
        });

        const nameCell = row.insertCell();
        nameCell.classList.add('py-2', 'px-3', 'name-cell');
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = channel.name;
        nameInput.classList.add('shadow-inner', 'border', 'rounded', 'py-1', 'px-2', 'text-gray-700', 'leading-tight', 'focus:outline-none', 'focus:shadow-outline', 'text-sm', 'w-full');
nameInput.addEventListener('focus', () => {
    row.classList.add('editing-row'); // Applying the class on focus
    channel.isEditing = true;
});
	nameInput.addEventListener('blur', () => {
    row.classList.remove('editing-row'); // Removing the class on blur
    channel.isEditing = false;
            if (channel.name !== nameInput.value) {
                saveState();
                channel.name = nameInput.value;
            }
        });
        nameCell.appendChild(nameInput);

        const groupCell = row.insertCell();
            groupCell.classList.add('py-2', 'px-3', 'text-left');

            const groupInput = document.createElement('input');
            groupInput.type = 'text';
            groupInput.value = channel.groupTitle;
            groupInput.classList.add('w-full', 'border', 'rounded', 'py-1', 'px-2', 'text-sm');
            groupCell.appendChild(groupInput);

            groupInput.addEventListener('focus', () => {
                row.classList.add('editing-row');
                channel.isEditing = true;
            });
            groupInput.addEventListener('blur', () => {
                row.classList.remove('editing-row');
                channel.isEditing = false;
                const newGroupTitle = groupInput.value.trim();
                if (channel.groupTitle !== newGroupTitle) {
                    saveState();
                    channel.groupTitle = newGroupTitle;

                    // Re-render the cell content to ensure the input is always there
                    groupCell.innerHTML = ''; // Clear the cell
                    const newInput = document.createElement('input');
                    newInput.type = 'text';
                    newInput.value = newGroupTitle;
                    newInput.classList.add('w-full', 'border', 'rounded', 'py-1', 'px-2', 'text-sm');
                    groupCell.appendChild(newInput);

                    // Re-attach the event listeners to the *new* input
                    newInput.addEventListener('focus', () => {
                        row.classList.add('editing-row');
                        channel.isEditing = true;
                    });
                    newInput.addEventListener('blur', () => {
                        row.classList.remove('editing-row');
                        channel.isEditing = false;
                        const updatedGroupTitle = newInput.value.trim();
                        if (channel.groupTitle !== updatedGroupTitle) {
                            saveState();
                            channel.groupTitle = updatedGroupTitle;
                            applyFilters();
                            renderTable(visibleChannels); // Re-render the entire table if needed
                            updateStatus();
                        }
                    });

                    updateStatus();
                }
            });
			
			
        const datalistId = `group-suggestions-${originalIndex}`;
        const datalist = document.createElement('datalist');
        datalist.id = datalistId;

        const uniqueGroups = getUniqueGroups(allChannels);
        uniqueGroups.forEach(group => {
            const option = document.createElement('option');
            option.value = group;
            datalist.appendChild(option);
        });

        groupInput.setAttribute('list', datalistId);

groupInput.addEventListener('focus', () => {
    row.classList.add('editing-row'); // Applying the class on focus
    channel.isEditing = true;
            groupInput.dataset.originalValue = channel.groupTitle;
            groupInput.select(); // Select text on focus for easy replacement
        });

        groupInput.addEventListener('focus', () => {
    row.classList.add('editing-row'); // Applying the class on focus
    channel.isEditing = true;
            if (channel.groupTitle !== groupInput.value) {
                saveState();
                channel.groupTitle = groupInput.value;
            } else if (groupInput.value === '' && channel.groupTitle !== groupInput.dataset.originalValue) {
                channel.groupTitle = groupInput.dataset.originalValue;
                groupInput.value = channel.groupTitle;
                renderTable(allChannels); // Re-render using allChannels
            }
        });

        groupCell.appendChild(groupInput);
        groupCell.appendChild(datalist);

        const countryCell = row.insertCell();
        countryCell.classList.add('py-2', 'px-3', 'country-cell');
        const countryCodeMatch = channel.tvgId.match(/([A-Za-z]{2})$/);
        countryCell.textContent = countryCodeMatch ? countryCodeMatch[1].toUpperCase() : '';

        const copyButtonCell = row.insertCell();
        copyButtonCell.classList.add('py-2', 'px-3', 'copy-url-cell');
        const copyButton = document.createElement('button');
        copyButton.textContent = 'Copy URL';
        copyButton.classList.add('bg-gray-400', 'hover:bg-gray-500', 'text-white', 'font-bold', 'py-1', 'px-2', 'rounded', 'text-xs');
  copyButton.addEventListener('click', () => {
            const originalText = copyButton.textContent;
            const originalClasses = [...copyButton.classList]; // Store original classes

            navigator.clipboard.writeText(channel.url).then(() => {
                copyButton.textContent = 'COPIED';
                copyButton.classList.remove(...originalClasses); // Remove all original classes
                copyButton.classList.add('bg-yellow-500', 'text-black', 'font-bold', 'py-1', 'px-2', 'rounded', 'text-xs');

                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.classList.remove('bg-yellow-500', 'text-black');
                    copyButton.classList.add(...originalClasses); // Re-apply original classes
                }, 1500); // Revert after 1.5 seconds
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert('Failed to copy URL to clipboard.'); // Keep the alert for failure
            });
        });
        copyButtonCell.appendChild(copyButton);
    });
    updateStatus();
}

        // --- Event Listeners ---
        loadButton.addEventListener('click', () => {
            fileInput.click();
        });


	fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        currentFile = file;
        currentFileSpan.textContent = currentFile.name;

        // Indicate waiting state on the undo button
        undoButton.textContent = "WAIT...";
        undoButton.classList.add('bg-black');
        undoButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');

        if (file.name.endsWith('.m3u')) {
            const reader = new FileReader();
            reader.onload = (e) => {
                saveState();
                allChannels = [];
                const lines = e.target.result.split(/\r?\n/);
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].startsWith("#EXTINF")) {
                        const url = lines[i + 1];
                        const nameMatch = lines[i].match(/,(.*)$/);
                        const name = nameMatch ? nameMatch[1].trim() : "";
                        const logoMatch = lines[i].match(/tvg-logo="([^"]*)"/);
                        const logo = logoMatch ? logoMatch[1] : "";
                        const groupMatch = lines[i].match(/group-title="([^"]*)"/);
                        const group = groupMatch ? groupMatch[1] : "";
                        const tvgIdMatch = lines[i].match(/tvg-id="([^"]*)"/);
                        const tvgId = tvgIdMatch ? tvgIdMatch[1] : "";
                        allChannels.push({ name, groupTitle: group, tvgLogo: logo, tvgId, url, selected: false, played: false });
                        i++;
                    }
                }
                visibleChannels = [...allChannels];
                renderTable(visibleChannels);

                updateStatus();
				
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }

                // Revert button appearance after loading
                setTimeout(() => {
                    undoButton.textContent = "Undo";
                    undoButton.classList.remove('bg-black');
                    undoButton.classList.add('bg-yellow-500');
                    undoButton.classList.add('hover:bg-yellow-700');
                }, 100);
            };
            reader.readAsText(file);
        } else if (file.name.endsWith('.xlsx')) {
            alert("XLSX loading to GUI will be implemented later.");
            fileInput.value = ''; // Reset file input
            // Revert button appearance even if loading fails or is skipped
            setTimeout(() => {
                undoButton.textContent = "Undo";
                undoButton.classList.remove('bg-black');
                undoButton.classList.add('bg-yellow-500');
                undoButton.classList.add('hover:bg-yellow-700');
            }, 100);
        } else {
            alert('Please select a valid .m3u file to load.');
            fileInput.value = ''; // Reset file input
            // Revert button appearance on invalid file
            setTimeout(() => {
                undoButton.textContent = "Undo";
                undoButton.classList.remove('bg-black');
                undoButton.classList.add('bg-yellow-500');
                undoButton.classList.add('hover:bg-yellow-700');
            }, 100);
        }
    });

        searchInput.addEventListener('input', filterChannels);
		groupFilterInput.addEventListener('input', applyFilters); // Apply filters on group input change
        duplicatesButton.addEventListener('click', findDuplicateUrls);
        undoButton.addEventListener('click', restoreState);

	let showingSelectedToDelete = false;
        let previousFilter = null; // To store the previous filter state

        deleteSelectedButton.addEventListener('click', () => {
            if (!showingSelectedToDelete) {
                previousFilter = searchInput.value; // Store the current search term
                const selectedChannels = allChannels.filter(channel => channel.selected);
                visibleChannels = selectedChannels;
                renderTable(visibleChannels);
		
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }3
                deleteSelectedButton.textContent = 'Confirm Delete';
                showingSelectedToDelete = true;
            } else {
                saveState();
                const selectedVisibleToDelete = visibleChannels.filter(channel => channel.selected);
                deletedChannels.push(...selectedVisibleToDelete);

                selectedVisibleToDelete.forEach(deleted => {
                    const indexInAll = allChannels.indexOf(deleted);
                    if (indexInAll > -1) {
                        allChannels.splice(indexInAll, 1);
                    }
                });

                // Restore previous filter or show all
                if (previousFilter) {
                    searchInput.value = previousFilter;
                    filterChannels(); // Apply the previous filter
                } else {
                    visibleChannels = [...allChannels];
                    renderTable(visibleChannels);
					
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
                }

                updateStatus();
                deleteSelectedButton.textContent = 'Delete Selected';
                showingSelectedToDelete = false;
                previousFilter = null; // Reset the stored filter
            }
        });

        exportM3uButton.addEventListener('click', () => {
            if (allChannels.length > 0) {
                const m3uContent = exportM3UContent(allChannels);
                const filename = generateFilename('m3u');
                downloadFile(m3uContent, filename, 'audio/x-mpegurl');
            } else {
                alert('No channels to export.');
            }
        });

m3uToXlsxButton.addEventListener('click', () => {
      triggerM3UtoXLSX();
   });

   xlsxToM3uButton.addEventListener('click', () => {
      triggerXLSXtoM3U();
   });

	selectAllCheckbox.addEventListener('change', () => {
				visibleChannels.forEach(channel => channel.selected = selectAllCheckbox.checked);
				renderTable(visibleChannels);
				
				updateStatus();
				
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }
			});

			// Initial render (in case there's data loaded some other way later)
			renderTable(visibleChannels);
			updateStatus();
			
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            rowCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });

            allChannels.forEach(channel => {
                channel.selected = isChecked;
            });

            renderTable(visibleChannels);
            updateStatus();
        });
    } else {
        console.error("Select All checkbox element with ID 'select-all' not found (attached after renderTable).");
    }

document.addEventListener('DOMContentLoaded', () => {
    const selectAllCheckbox = document.querySelector('thead th:first-child input[type="checkbox"]');
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', () => {
            const isChecked = selectAllCheckbox.checked;
            const rowCheckboxes = document.querySelectorAll('#playlist-table-body .row-select');

            // Indicate waiting state
            undoButton.textContent = "WAIT...";
            undoButton.classList.add('bg-black');
            undoButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');

            setTimeout(() => {
                rowCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                });

                allChannels.forEach(channel => {
                    channel.selected = isChecked;
                });

                renderTable(visibleChannels);
                updateStatus();

                // Revert button appearance
                setTimeout(() => {
                    undoButton.textContent = "Undo";
                    undoButton.classList.remove('bg-black');
                    undoButton.classList.add('bg-yellow-500');
                    undoButton.classList.add('hover:bg-yellow-700');
                }, 100);
            }, 0);
        });
    } else {
        console.error("Select All checkbox element not found using querySelector.");
    }
});

deleteSelectedButton.addEventListener('click', () => {
        if (!showingSelectedToDelete) {
            previousFilter = searchInput.value; // Store the current search term
            const selectedChannels = allChannels.filter(channel => channel.selected);
            visibleChannels = selectedChannels;
            renderTable(visibleChannels);
            searchInput.value = '';
            updateStatus();
            deleteSelectedButton.textContent = `Confirm Delete (${selectedChannels.length})`; // Use selectedChannels.length
            showingSelectedToDelete = true;
        } else {
            saveState();

            // Indicate waiting state
            undoButton.textContent = "WAIT...";
            undoButton.classList.add('bg-black');
            undoButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-700');

            setTimeout(() => {
                const selectedVisibleToDelete = visibleChannels.filter(channel => channel.selected);
                deletedChannels.push(...selectedVisibleToDelete);

                selectedVisibleToDelete.forEach(deleted => {
                    const indexInAll = allChannels.indexOf(deleted);
                    if (indexInAll > -1) {
                        allChannels.splice(indexInAll, 1);
                    }
                });

                // Restore previous filter or show all
                if (previousFilter) {
                    searchInput.value = previousFilter;
                    filterChannels(); // Apply the previous filter
                } else {
                    visibleChannels = [...allChannels];
                    renderTable(visibleChannels);
                }

                updateStatus();
                deleteSelectedButton.textContent = 'Delete Selected';
                showingSelectedToDelete = false;
                previousFilter = null; // Reset the stored filter

                // Revert button appearance
                setTimeout(() => {
                    undoButton.textContent = "Undo";
                    undoButton.classList.remove('bg-black');
                    undoButton.classList.add('bg-yellow-500');
                    undoButton.classList.add('hover:bg-yellow-700');
                }, 100);
            }, 0);
        }
    });

    </script>