<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>IPTV Playlist Editor</title>
<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="IPTV ds" />
<link rel="manifest" href="/site.webmanifest" />
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

0223
	
<style>
  /* Background adjusted to Tailwind gray-400 similar to button row */
  body {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,
      "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }

  /* Make container background same as page bg */
  #layout-container {
    background-color: #e5e7eb; /* Tailwind gray-200 */
    padding: 0.5rem 0.75rem;
    min-height: 100vh;
    box-sizing: border-box;
    max-width: 1200px; /* Max width for centering */
    margin: 0 auto; /* Center the container */
  }

  /* Sticky Header Block Container */
  .sticky-header-block {
    position: sticky;
    top: 0;
    z-index: 10; /* Ensure it stays on top */
    background-color: #d1d5db; /* Match header background */
    width: 100%; /* Ensure it takes full width */
  }

  /* Table styling */
  table {
    background-color: #c2c2c2 !important; /* Slightly darker than gray-300 */
    border-collapse: collapse !important; /* Collapsed borders */
    border-spacing: 0 !important; /* Removed spacing */
    width: 100%; /* Table takes full width of its container */
    min-width: 700px; /* Ensure minimum width for horizontal scroll on desktop */
    border-radius: 0.5rem;
    overflow: hidden;
    margin-bottom: 0; /* Remove bottom margin */
    table-layout: fixed; /* Use fixed layout for consistent column widths */
  }

  /* Table Header Styling */
  #playlist-table-header thead tr {
    background: none !important; /* Remove background */
    border-bottom: 1px solid #9ca3af !important; /* Add bottom border */
    height: 30px; /* Reduced height */
    box-sizing: border-box;
  }
   #playlist-table-header {
        margin-bottom: 0; /* Remove margin below header table */
        border-bottom-left-radius: 0; /* Adjust border radius */
        border-bottom-right-radius: 0; /* Adjust border radius */
   }

  th, td {
    padding: 2px !important; /* Reduced padding */
    font-size: 12px;
    white-space: nowrap;
    box-sizing: border-box;
    border: none !important; /* Remove individual cell borders, will use row/column borders */
    text-align: left; /* Default text alignment for data cells */
    vertical-align: middle !important; /* Vertically align content */
    overflow: hidden; /* Hide content that overflows fixed width */
    text-overflow: ellipsis; /* Add ellipsis for overflowing text */
  }
   th {
        text-align: center; /* Default text alignment for headers */
        vertical-align: middle !important; /* Vertically align header content */
   }

  /* Add borders to create grid lines */
   td {
    border-right: 1px solid #d1d5db !important; /* Add right border to cells */
   }
   td:last-child {
    border-right: none !important; /* Remove right border from last cell */
   }
   #playlist-table-body-table tbody tr {
    border-bottom: 1px solid #d1d5db !important; /* Add bottom border to rows */
   }
   #playlist-table-body-table tbody tr:last-child {
    border-bottom: none !important; /* Remove bottom border from last row */
   }

    /* Define fixed widths for columns (Desktop) */
    #playlist-table-header th:nth-child(1), #playlist-table-body-table td:nth-child(1) { width: 20px !important; } /* Checkbox */
    #playlist-table-header th:nth-child(2), #playlist-table-body-table td:nth-child(2) { width: 25px !important; } /* # */
    #playlist-table-header th:nth-child(3), #playlist-table-body-table td:nth-child(3) { width: 25px !important; } /* Play */
    #playlist-table-header th:nth-child(4), #playlist-table-body-table td:nth-child(4) { width: 35px !important; } /* Logo */
    #playlist-table-header th:nth-child(5), #playlist-table-body-table td:nth-child(5) { width: 220px !important; text-align: left !important; } /* Name */
    #playlist-table-header th:nth-child(6), #playlist-table-body-table td:nth-child(6) { width: 220px !important; text-align: left !important; } /* Group */
    #playlist-table-header th:nth-child(7), #playlist-table-body-table td:nth-child(7) { width: 50px !important; text-align: center !important; } /* Country */
    #playlist-table-header th:nth-child(8), #playlist-table-body-table td:nth-child(8) { width: 130px !important; text-align: center !important; } /* URL */


  .logo-cell img {
      height: 24px !important; /* Constant height for logo */
      width: auto !important; /* Allow width to adjust */
      object-fit: cover !important; /* Crop if too wide */
      display: block !important; /* Ensure image is treated as a block for centering */
      margin: 0 auto !important; /* Center image horizontally */
    }

  .country-cell select {
        width: 100%; /* Ensure select takes full width of cell */
        box-sizing: border-box;
        display: block; /* Ensure select is treated as a block */
        margin: 0 auto; /* Center select horizontally */
   }
   .country-cell th select {
       display: inline-block; /* Keep select in header inline */
       width: auto; /* Allow width to be determined by content */
   }

  .name-cell input[type="text"], .group-cell input[type="text"] {
        width: 100%; /* Ensure inputs take full width of their cells */
        box-sizing: border-box;
   }


  /* Smaller paddings for all controls */
  input[type="checkbox"] {
    width: 20px !important; /* Adjusted checkbox size to match play button */
    height: 20px !important; /* Adjusted checkbox size to match play button */
    margin: 0 !important; /* Remove default margin */
    box-sizing: border-box !important;
  }

  /* Common button style */
  button {
    font-size: 0.8rem;
    min-height: unset;
    min-width: unset;
    padding: 0.2rem 0.5rem !important; /* Reduced padding */
    height: 24px; /* Adjusted height */
    line-height: 1;
    box-sizing: border-box;
    display: flex; /* Use flexbox for centering text */
    justify-content: center; /* Center text horizontally */
    align-items: center; /* Center text vertically */
  }
  input[type="text"], input[type="search"], select {
    height: 24px !important; /* Match button height */
    padding: 0.1rem 0.3rem !important; /* Adjust padding */
    box-sizing: border-box !important;
  }

  /* Status bar styling */
  #status-bar {
    /* Position and top handled by .sticky-header-block */
    z-index: 10;
    background-color: #d1d5db;
    padding: 0.2rem 0.75rem !important; /* Reduced padding */
    color: black;
    font-size: 0.8rem;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 0.3rem;
    height: 30px; /* Reduced height */
    box-sizing: border-box;
  }
   #status-bar button {
    height: 24px !important; /* Match other buttons */
    padding: 0.2rem 0.5rem !important; /* Match other buttons */
    box-sizing: border-sizing !important;
  }


  /* Button row styling */
  #button-row {
    /* Position and top handled by .sticky-header-block */
    z-index: 9;
    background-color: #d1d5db;
    display: flex;
    flex-wrap: wrap; /* Allow wrapping on mobile */
    gap: 0.4rem;
    padding: 0.2rem 0.75rem !important; /* Reduced padding */
    justify-content: flex-start;
    align-items: left;
    height: 30px; /* Reduced height */
    box-sizing: border-box;
  }


  /* Container adjustment for smaller viewport */
  #playlist-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    max-width: 100vw;
    /* Removed margin-top - sticky positioning handles space */
  }
   #table-header-container {
        /* This container is now part of the sticky block */
         width: 100%; /* Ensure it takes full width */
    }
    #playlist-body-container {
        overflow-x: auto; /* Enable horizontal scroll for table body */
        -webkit-overflow-scrolling: touch;
        max-width: 100vw;
    }
     #playlist-body-container table {
        margin-top: 0; /* Remove margin-top from the table body */
        border-top-left-radius: 0; /* Adjust border radius */
        border-top-right-radius: 0; /* Adjust border radius */
    }


  /* Popup styles remain the same */
  #popup-container {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.75);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
  }
  #popup-container.visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  #popup-container video {
    width: 90vw;
    max-width: 600px;
    height: auto;
    border-radius: 0.5rem;
  }

  /* Row highlight classes */
  .played-permanently {
    background-color: rgba(128, 0, 128, 0.1) !important;
  }
  .selected-row {
    background-color: rgba(255, 255, 0, 0.3) !important;
  }
  .edited {
    background-color: #c0c0c0 !important;
  }
  .editing-row {
    background-color: rgba(0, 255, 0, 0.2) !important;
  }
  #playlist-table-body tr td { vertical-align: middle; }
  #playlist-table-body tr.selected-row td { background-color: rgba(255, 255, 0, 0.3) !important; }
  #playlist-table-body tr.edited td { background-color: #c0c0c0 !important; }
  #playlist-table-body tr.editing-row td { background-color: rgba(0, 255, 0, 0.2) !important; }
  #playlist-table-body tr.played-permanently td { background-color: rgba(128, 0, 128, 0.1) !important; }


  /* Wait button color */
  .bg-black {
    background-color: black;
    color: white !important;
  }

  /* Responsive tweaks */
@media (max-width: 640px) {
    /* ... (other mobile styles remain here) ... */

    /* Status bar buttons - position after text, allow wrap to max 2 lines */
    #status-bar {
      flex-direction: column; /* Stack items vertically */
      align-items: flex-start; /* Align items to the start */
      height: auto; /* Allow height to adjust based on content */
      max-height: 60px; /* Approximate max height for 2 lines */
      overflow: hidden; /* Hide overflow if more than 2 lines */
      gap: 0.1rem; /* Reduce gap between stacked items */
      padding: 0.2rem 0.75rem !important; /* Ensure padding is correct */
    }
     #status-bar > div:first-child { /* Status text container */
        width: 100%; /* Take full width */
        margin-bottom: 0.2rem; /* Add a small bottom margin to separate from buttons */
        text-align: center; /* Center the status text */
     }
     #status-bar > div:last-child { /* Buttons container */
        width: 100%; /* Take full width */
        display: flex; /* Use flex for buttons within this container */
        flex-wrap: wrap; /* Allow buttons to wrap */
        gap: 0.3rem; /* Gap between buttons */
        justify-content: center; /* Center the block of buttons horizontally */
     }

     /* ... (other mobile styles remain here) ... */
  }

    /* Button row - allow simple wrapping */
     #button-row {
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.4rem;
      height: auto;
      justify-content: center; /* Center buttons when wrapped */
     }

    /* Buttons scaled down about half-width and 30% height less */
    #button-row button,
    #status-bar button {
      min-height: unset !important;
      min-width: unset !important;
      padding: 0.2rem 0.3rem !important;
      font-size: 0.8rem !important;
      flex-grow: unset !important;
      width: auto !important;
      height: 24px; /* Match desktop height */
    }
    /* Define fixed widths for columns (Mobile) */
    #playlist-table-header th:nth-child(1), #playlist-table-body-table td:nth-child(1) { width: 20px !important; } /* Checkbox */
    #playlist-table-header th:nth-child(2), #playlist-table-body-table td:nth-child(2) { width: 25px !important; } /* # */
    #playlist-table-header th:nth-child(3), #playlist-table-body-table td:nth-child(3) { width: 25px !important; } /* Play */
    #playlist-table-header th:nth-child(4), #playlist-table-body-table td:nth-child(4) { width: 35px !important; } /* Logo */
    #playlist-table-header th:nth-child(5), #playlist-table-body-table td:nth-child(5) { width: 165px !important; text-align: left !important; } /* Name (Reduced for mobile) */
    #playlist-table-header th:nth-child(6), #playlist-table-body-table td:nth-child(6) { width: 100px !important; text-align: left !important; } /* Group (Reduced for mobile) */
    #playlist-table-header th:nth-child(7), #playlist-table-body-table td:nth-child(7) { width: 50px !important; text-align: center !important; } /* Country */
    #playlist-table-header th:nth-child(8), #playlist-table-body-table td:nth-child(8) { width: 60px !important; text-align: center !important; } /* URL (Adjusted for mobile) */


     /* Logo size on mobile */
    .logo-cell img {
      height: 24px !important; /* Constant height for logo */
      width: auto !important; /* Allow width to adjust */
      object-fit: cover !important; /* Crop if too wide */
      display: block !important; /* Ensure image is treated as a block for centering */
      margin: 0 auto !important; /* Center image horizontally */
    }
     .copy-url-cell button {
        width: 100% !important; /* Button takes full width of cell */
        background-color: #4b5563 !important; /* Tailwind gray-600, slightly darker */
     }


  }
</style>
</head>
<body>

	<div id="layout-container">

  <div class="sticky-header-block">
    <div id="status-bar" class="flex justify-between items-center bg-gray-300 text-black p-2 text-sm flex-wrap gap-2">
      <div>
        Total: <span id="total-channels">0</span> |
        Selected: <span id="selected-channels">0</span> |
        Deleted: <span id="deleted-channels">0</span> |
        Edited: <span id="edited-channels">0</span> |
        File: <span id="current-file">None</span>
      </div>
      <div class="flex gap-2 flex-wrap">
        <button id="m3uToXlsxButton" class="bg-blue-600 hover:bg-blue-800 text-white font-bold py-1 px-3 rounded text-xs" aria-label="Convert M3U to XLSX">M3U → XLSX</button>
        <button id="xlsxToM3uButton" class="bg-green-600 hover:bg-green-800 text-white font-bold py-1 px-3 rounded text-xs" aria-label="Convert XLSX to M3U">XLSX → M3U</button>
        <input type="file" id="convertM3U" class="hidden" accept=".m3u" />
        <input type="file" id="convertXLSX" class="hidden" accept=".xlsx" />
      </div>
    </div>

    <div id="button-row" class="bg-gray-300 p-2 shadow-sm flex flex-wrap gap-4 items-center">
      <input type="file" id="file-input" class="hidden" accept=".m3u,.xlsx" />
      <button id="load-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded text-sm" aria-label="Load playlist">Load</button>
      <button id="export-m3u-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded text-sm" aria-label="Export as M3U">Export</button>
      <input type="search" id="search-input" placeholder="Search channel name" aria-label="Search channel name" autocomplete="off" class="shadow border rounded py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-sm" />
      <input type="text" id="group-filter-input" placeholder="Filter by group" aria-label="Filter by group" autocomplete="off" list="group-suggestions" class="shadow border rounded py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-sm" />
      <datalist id="group-suggestions"></datalist>
      <button id="delete-selected-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded text-sm" aria-label="Show selected channels">Selected</button>
      <button id="duplicates-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded text-sm" aria-label="Show duplicate channels">Dupes</button> <button id="undo-button" class="bg-yellow-500 hover:bg-yellow-700 text-black font-bold py-2 px-4 rounded text-sm" aria-label="Undo last action">Undo</button>
      <button id="cancel-delete" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded text-sm hidden" aria-label="Show all channels">Show All</button>
    </div>

    <table id="playlist-table-header" class="shadow-md rounded w-full">
        <thead>
          <tr>
            <th><input type="checkbox" id="select-all" aria-label="Select all channels" /></th>
            <th class="cursor-pointer text-center">#</th>
            <th class="text-center">Play</th>
            <th class="logo-cell">Logo</th>
            <th class="text-left">Name</th>
            <th class="text-left">Group</th>
            <th>
              <select id="country-filter" aria-label="Filter by country" class="shadow border rounded py-1 px-2 text-gray-700 leading-tight focus:outline-none focus:shadow-outline text-xs">
                <option value="">All</option>
                <option value="BLANK">Blank</option>
              </select>
            </th>
            <th class="copy-url-cell">URL</th>
          </tr>
        </thead>
     </table>
  </div>

  <div id="playlist-body-container" class="overflow-x-auto">
     <table id="playlist-table-body-table" class="shadow-md rounded w-full">
        <tbody id="playlist-table-body"></tbody>
     </table>
  </div>

</div>

<div id="popup-container" class="fixed inset-0 flex justify-center items-center bg-black bg-opacity-75 opacity-0 invisible pointer-events-none transition-opacity duration-300" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="relative w-[90vw] max-w-xl h-[56.25vw] max-h-[360px] bg-gray-900 rounded-lg shadow-lg">
    <video id="popup-player" controls class="w-full h-full rounded-lg" aria-label="Stream player">
      <source id="popup-video-source" src="" type="application/x-mpegURL" />
      Your browser does not support video playback.
    </video>
  </div>
</div>

<script>

  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }

  // Cached Elements
  const fileInput = document.getElementById('file-input');
  const loadButton = document.getElementById('load-button');
  const searchInput = document.getElementById('search-input');
  const groupFilterInput = document.getElementById('group-filter-input');
  const undoButton = document.getElementById('undo-button');
  const deleteSelectedButton = document.getElementById('delete-selected-button');
  const duplicatesButton = document.getElementById('duplicates-button');
  const exportM3uButton = document.getElementById('export-m3u-button');
  const selectAllCheckbox = document.getElementById('select-all');
  const playlistTableBody = document.getElementById('playlist-table-body');
  const totalChannelsSpan = document.getElementById('total-channels');
  const selectedChannelsSpan = document.getElementById('selected-channels');
  const deletedChannelsSpan = document.getElementById('deleted-channels');
  const editedChannelsSpan = document.getElementById('edited-channels');
  const currentFileSpan = document.getElementById('current-file');
  const countryFilter = document.getElementById('country-filter');

  const convertM3UInput = document.getElementById('convertM3U');
  const convertXLSXInput = document.getElementById('convertXLSX');
  const m3uToXlsxButton = document.getElementById('m3uToXlsxButton');
  const xlsxToM3uButton = document.getElementById('xlsxToM3uButton');

  // State
  let allChannels = [];
  let visibleChannels = [];
  let deletedChannels = [];
  let editedChannels = 0;
  let history = [];
  let currentFile = null;
  let duplicatesActive = false;
  let showingSelectedToDelete = false;
  let previousFilter = null;

  function saveState() {
    history.push({
      allChannels: JSON.parse(JSON.stringify(allChannels)),
      deletedChannels: [...deletedChannels]
    });
    if (history.length > 10) history.shift();
  }

  function updateStatus() {
    totalChannelsSpan.textContent = allChannels.length;
    selectedChannelsSpan.textContent = allChannels.filter(c => c.selected).length;
    deletedChannelsSpan.textContent = deletedChannels.length;
    editedChannelsSpan.textContent = editedChannels;
    currentFileSpan.textContent = currentFile ? currentFile.name : 'None';
  }

  function downloadFile(content, filename, contentType) {
    const a = document.createElement('a');
    if (content instanceof Blob) {
      a.href = URL.createObjectURL(content);
    } else {
      a.href = 'data:' + contentType + ',' + encodeURIComponent(content);
    }
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  loadButton.addEventListener('click', () => { showWaitOnUndoButton(); fileInput.click(); });
  m3uToXlsxButton.addEventListener('click', () => convertM3UInput.click());
  xlsxToM3uButton.addEventListener('click', () => convertXLSXInput.click());

  fileInput.addEventListener('change', (evt) => {
    const file = evt.target.files[0];
    if (!file) return;
    currentFile = file;
    currentFileSpan.textContent = currentFile.name;

    if (file.name.endsWith('.m3u')) {
      const reader = new FileReader();
      reader.onload = (e) => {
        saveState();
        allChannels = [];
        const lines = e.target.result.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].startsWith("#EXTINF")) {
            const url = lines[i + 1] || "";
            const nameMatch = lines[i].match(/,(.*)$/);
            const name = nameMatch ? nameMatch[1].trim() : "";
            const logoMatch = lines[i].match(/tvg-logo=\"([^"]*)\"/);
            const logo = logoMatch ? logoMatch[1] : "";
            const groupMatch = lines[i].match(/group-title=\"([^"]*)\"/);
            const groupTitle = groupMatch ? groupMatch[1] : "";
            const tvgIdMatch = lines[i].match(/tvg-id=\"([^"]*)\"/);
            const tvgId = tvgIdMatch ? tvgIdMatch[1] : "";
            allChannels.push({
              name,
              groupTitle,
              tvgLogo: logo,
              tvgId,
              url,
              selected: false,
              played: false,
              playedPermanently: false,
              edited: false,
              isEditing: false
            });
            i++;
          }
        }
        visibleChannels = [...allChannels];
        updateGroupSuggestions();
        renderTable(visibleChannels);
        populateCountryDropdown();
        updateStatus();
        resetUndoButton();
      };
      reader.readAsText(file);
    } else if (file.name.endsWith('.xlsx')) {
      alert("XLSX loading to GUI will be implemented later.");
      fileInput.value = "";
      resetUndoButton();
    } else {
      alert("Please select a valid .m3u file to load.");
      fileInput.value = "";
      resetUndoButton();
    }
  });

  convertM3UInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    handleM3UtoXLSX(file);
  });

  convertXLSXInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    handleXLSXtoM3U(file);
  });

  // Conversion functions as in your original code...

  function handleM3UtoXLSX(file) {
    // ... as given before, use your original logic
    const reader = new FileReader();
    reader.onload = function(e) {
      const lines = e.target.result.split(/\r?\n/);
      const data = [["Name", "Group", "Logo", "tvg-id", "URL"]];
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith("#EXTINF")) {
          const info = lines[i];
          const url = lines[i + 1] || "";
          const name = (info.match(/,(.*)$/) || [])[1] || "Unknown";
          const logo = (info.match(/tvg-logo=\"(.*?)\"/) || [])[1] || "";
          const group = (info.match(/group-title=\"(.*?)\"/) || [])[1] || "";
          const tvgid = (info.match(/tvg-id=\"(.*?)\"/) || [])[1] || "";
          data.push([name, group, logo, tvgid, url]);
          i++;
        }
      }
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Playlist");
      const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([new Uint8Array(excelBuffer)], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8' });
      const filename = file.name.replace(/\.[^/.]+$/, "") + ".xlsx";
      downloadFile(blob, filename, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8');
    };
    reader.readAsText(file);
  }

  function handleXLSXtoM3U(file) {
    // ... as given before, use your original logic
    const reader = new FileReader();
    reader.onload = function(e) {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: "array" });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
      const [header, ...entries] = rows;
      const m3u = ["#EXTM3U"];
      for (const row of entries) {
        const name = row[0] || "";
        const group = row[1] || "";
        const logo = row[2] || "";
        const tvgid = row[3] || "";
        const url = row[4] || "";
        m3u.push(`#EXTINF:-1 tvg-id="${tvgid}" tvg-logo="${logo}" group-title="${group}",${name}`);
        m3u.push(url);
      }
      const m3uContent = m3u.join("\n");
      const filename = file.name.replace(/\.[^/.]+$/, "") + ".m3u";
      downloadFile(m3uContent, filename, 'text/plain;charset=utf-8');
    };
    reader.readAsArrayBuffer(file);
  }

  // Show/hide popup player
  const popupContainer = document.getElementById("popup-container");
  const popupPlayer = document.getElementById("popup-player");

  function showPopup() {
    popupContainer.classList.add("visible");
    popupContainer.setAttribute("aria-hidden", "false");
  }
  function hidePopup() {
    popupContainer.classList.remove("visible");
    popupContainer.setAttribute("aria-hidden", "true");
    if (popupPlayer.hlsInstance) {
      popupPlayer.hlsInstance.destroy();
      popupPlayer.hlsInstance = null;
    }
    popupPlayer.pause();
    popupPlayer.src = "";
  }
  popupContainer.addEventListener("click", (evt) => {
    if (!evt.target.closest("#popup-player")) {
      hidePopup();
    }
  });

  // Show error messages with clean cancel and download handlers
  function showErrorMessage(streamUrl, channel) {
    if (document.getElementById("error-message")) return;

    const errorMessage = document.createElement("div");
    errorMessage.id = "error-message";
    errorMessage.innerHTML = `
      <p>Failed to load the stream—possibly due to restrictions.</p>
      <button id="download-m3u" class="bg-blue-600 text-white px-4 py-2 rounded mr-2">Download M3U</button>
      <button id="cancel-playback" class="bg-gray-600 text-white px-4 py-2 rounded">Cancel</button>
    `;
    errorMessage.style.position = "fixed";
    errorMessage.style.top = "50%";
    errorMessage.style.left = "50%";
    errorMessage.style.transform = "translate(-50%, -50%)";
    errorMessage.style.background = "white";
    errorMessage.style.padding = "1rem 1.5rem";
    errorMessage.style.borderRadius = "0.5rem";
    errorMessage.style.zIndex = 1100;
    errorMessage.style.textAlign = "center";
    document.body.appendChild(errorMessage);

    document.getElementById("download-m3u").addEventListener("click", () => {
      const m3uContent = `#EXTM3U\n#EXTINF:-1,${channel.name}\n${streamUrl}`;
      const blob = new Blob([m3uContent], { type: 'application/vnd.apple.mpegurl' });
      const downloadLink = document.createElement("a");
      downloadLink.href = URL.createObjectURL(blob);
      downloadLink.download = `${channel.name.replace(/[^a-zA-Z0-9]/g, "")}.m3u`;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
      if (errorMessage && errorMessage.parentNode) {
        errorMessage.parentNode.removeChild(errorMessage);
      }
    });

    document.getElementById("cancel-playback").addEventListener("click", () => {
      if (errorMessage && errorMessage.parentNode) {
        errorMessage.parentNode.removeChild(errorMessage);
      }
    });
  }

  // Render the playlist table fully, including the play button with fixed visibility and logic
  function renderTable(channels) {
    playlistTableBody.innerHTML = "";
    const fragment = document.createDocumentFragment();

    channels.forEach((channel) => {
      const originalIndex = allChannels.indexOf(channel);
      const row = document.createElement("tr");

      if (channel.selected) row.classList.add("selected-row");
      if (channel.isEditing) row.classList.add("editing-row");
      if (channel.edited) row.classList.add("edited");
      if (channel.playedPermanently) row.classList.add("played-permanently");
      row.classList.add("hover:bg-gray-100");

      // Checkbox cell
      let td = document.createElement("td");
      td.style.paddingLeft = "0";
      td.style.paddingRight = "0";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = channel.selected;
      checkbox.style.margin = "0";
      checkbox.addEventListener("change", () => {
        channel.selected = checkbox.checked;
        row.classList.toggle("selected-row", channel.selected);
        updateStatus();
      });
      td.appendChild(checkbox);
      row.appendChild(td);

      // Channel number cell
      td = document.createElement("td");
      td.textContent = originalIndex + 1;
      td.classList.add("channel-number", "cursor-pointer");
      td.style.textAlign = "center";
      td.style.padding = "0.1rem";
      td.addEventListener("click", () => {
        const moveBefore = prompt(`Move channel #${originalIndex + 1} before channel # (enter number):`);
        if (moveBefore !== null && moveBefore.trim() !== "") {
          const targetIndex = parseInt(moveBefore) - 1;
          if (
            !isNaN(targetIndex) &&
            targetIndex >= 0 &&
            targetIndex < allChannels.length &&
            targetIndex !== originalIndex
          ) {
            saveState();
            undoButton.textContent = "WAIT...";
            undoButton.classList.add("bg-black");
            undoButton.classList.remove("bg-yellow-500", "hover:bg-yellow-700");
           setTimeout(() => {
              const channelToMove = allChannels[originalIndex];
              allChannels.splice(originalIndex, 1);
              allChannels.splice(targetIndex, 0, channelToMove);
              applyFilters();
              renderTable(visibleChannels);
              resetUndoButton();
          }, 0); // Use 0 timeout to allow UI update
          } else if (targetIndex === originalIndex) {
            alert("You entered the current channel number. No change made.");
          } else {
            alert("Invalid channel number entered.");
          }
        }
      });
      row.appendChild(td);

      // Play button cell - FIXED visibility and click logic
      td = document.createElement("td");
      td.style.textAlign = "center";
      td.style.padding = "0.1rem";
      const playButton = document.createElement("button");
      playButton.textContent = "▶";
      playButton.classList.add("bg-indigo-500", "hover:bg-indigo-700", "text-white", "font-bold", "py-1", "px-2", "rounded", "text-xs");
      playButton.addEventListener("click", async () => {
        row.classList.add("played-permanently");
        const streamUrl = channel.url;

        if (!streamUrl) {
          alert("No stream URL");
          return;
        }

        showPopup();

        // Destroy previous HLS instance if any
        if (popupPlayer.hlsInstance) {
          popupPlayer.hlsInstance.destroy();
          popupPlayer.hlsInstance = null;
        }
        popupPlayer.onerror = null;

        try {
          const headResp = await fetch(streamUrl, { method: "HEAD" });
          if (!headResp.ok) throw new Error("Stream unreachable");
        } catch (err) {
          // Special fallback for certain URLs or non-.m3u8
          if (
            streamUrl.includes("tvpass.org") ||
            streamUrl.includes("stremioaddon") ||
            (!streamUrl.endsWith(".m3u8") && !streamUrl.match(/^https?:\/\/.*\.ts$/i))
          ) {
            const m3u = `#EXTM3U\n#EXTINF:-1,${channel.name}\n${streamUrl}`;
            const blob = new Blob([m3u], { type: "application/vnd.apple.mpegurl" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${channel.name.replace(/[^a-zA-Z0-9]/g, "")}.m3u`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            return;
          }
          showErrorMessage(streamUrl, channel);
          return;
        }

        if (streamUrl.includes(".m3u8")) {
          if (Hls.isSupported()) {
            const hls = new Hls();
            hls.loadSource(streamUrl);
            hls.attachMedia(popupPlayer);
            hls.on(Hls.Events.MANIFEST_PARSED, () => popupPlayer.play());
            hls.on(Hls.Events.ERROR, () => showErrorMessage(streamUrl, channel));
            popupPlayer.hlsInstance = hls;
          } else {
            showErrorMessage(streamUrl, channel);
          }
        } else {
          popupPlayer.src = streamUrl;
          popupPlayer.load();
          popupPlayer.play();
          popupPlayer.onerror = () => {
            if (
              streamUrl.includes("tvpass.org") ||
              streamUrl.includes("stremioaddon") ||
              (!streamUrl.endsWith(".m3u8") && !streamUrl.match(/^https?:\/\/.*\.ts$/i))
            ) {
              const m3uContent = `#EXTM3U\n#EXTINF:-1,${channel.name}\n${streamUrl}`;
              const blob = new Blob([m3uContent], { type: "application/vnd.apple.mpegurl" });
              const dlLink = document.createElement("a");
              dlLink.href = URL.createObjectURL(blob);
              dlLink.download = `${channel.name.replace(/[^a-zA-Z0-9]/g, "")}.m3u`;
              document.body.appendChild(dlLink);
              dlLink.click();
              document.body.removeChild(dlLink);
            } else {
              showErrorMessage(streamUrl, channel);
            }
          };
        }

        channel.played = true;
        channel.playedPermanently = true;
        updateStatus();
      });
      td.appendChild(playButton);
      row.appendChild(td);

      // Logo cell
      td = document.createElement("td");
      td.classList.add("logo-cell", "py-2", "px-3");
      const logoImg = document.createElement("img");
      logoImg.src = channel.tvgLogo || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
      logoImg.alt = "Logo";
      logoImg.classList.add("logo-img");
      logoImg.style.width = "30px";
      logoImg.style.height = "auto";
      logoImg.style.cursor = "pointer";
      logoImg.title = "Click to edit logo URL";
      logoImg.addEventListener("click", () => {
        const newLogoUrl = prompt("Enter new logo URL:", channel.tvgLogo);
        if (newLogoUrl !== null) {
          saveState();
          channel.tvgLogo = newLogoUrl;
          logoImg.src = newLogoUrl;
          channel.edited = true;
          row.classList.add("edited");
          autosave();
          resetUndoButton(); // Reset button after autosave if it was in WAIT state
        }
      });
      td.appendChild(logoImg);
      row.appendChild(td);

      // Name cell inline edit
      td = document.createElement("td");
      td.classList.add("name-cell", "py-2", "px-3");
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.value = channel.name;
      nameInput.classList.add("shadow-inner", "border", "rounded", "py-1", "px-2", "text-gray-700", "leading-tight", "focus:outline-none", "focus:shadow-outline", "text-sm", "w-full");
      nameInput.addEventListener("focus", () => {
        row.classList.add("editing-row");
        channel.isEditing = true;
      });
      nameInput.addEventListener("blur", () => {
        row.classList.remove("editing-row");
        channel.isEditing = false;
        if (channel.name !== nameInput.value.trim()) {
          saveState();
          channel.name = nameInput.value.trim();
          editedChannels++;
          channel.edited = true;
          row.classList.add("edited");
autosave();
          resetUndoButton(); // Reset button after autosave if it was in WAIT state
        }
      });
      td.appendChild(nameInput);
      row.appendChild(td);

      // Group cell inline edit
      td = document.createElement("td");
      td.classList.add("group-cell", "py-2", "px-3");
      const groupInput = document.createElement("input");
      groupInput.type = "text";
      groupInput.value = channel.groupTitle;
      groupInput.classList.add("shadow-inner", "border", "rounded", "py-1", "px-2", "text-gray-700", "leading-tight", "focus:outline-none", "focus:shadow-outline", "text-sm", "w-full");
      groupInput.setAttribute("list", "group-suggestions");
      groupInput.addEventListener("focus", () => {
        groupInput.select();
        row.classList.add("editing-row");
        channel.isEditing = true;
      });
      groupInput.addEventListener("blur", () => {
        row.classList.remove("editing-row");
        channel.isEditing = false;
        const newGroupTitle = groupInput.value.trim();
        if (channel.groupTitle !== newGroupTitle) {
          saveState();
          channel.groupTitle = newGroupTitle;
          editedChannels++;
          channel.edited = true;
          row.classList.add("edited");
          applyFilters();
          renderTable(visibleChannels);
          updateStatus();
applyFilters();
          renderTable(visibleChannels);
          updateStatus();
          autosave();
          resetUndoButton(); // Reset button after autosave if it was in WAIT state
        }
        applyFilters();
      });
      td.appendChild(groupInput);
      row.appendChild(td);

      // Country cell derived from tvgId
      td = document.createElement("td");
      td.classList.add("country-cell", "py-2", "px-3");
      const countryCodeMatch = channel.tvgId.match(/([A-Za-z]{2})$/);
      td.textContent = countryCodeMatch ? countryCodeMatch[1].toUpperCase() : "";
      row.appendChild(td);

      // URL cell with button
      td = document.createElement("td");
      td.classList.add("copy-url-cell", "py-2", "px-3");
      const copyButton = document.createElement("button");
      copyButton.textContent = "URL";
      copyButton.classList.add("bg-gray-400", "hover:bg-gray-500", "text-white", "font-bold", "py-1", "px-2", "rounded", "text-xs");
      copyButton.addEventListener("click", () => {
        const originalText = copyButton.textContent;
        const originalClasses = [...copyButton.classList];
        navigator.clipboard.writeText(channel.url).then(() => {
          copyButton.textContent = "COPIED";
          copyButton.classList.remove(...originalClasses);
          copyButton.classList.add("bg-yellow-500", "text-black", "font-bold", "py-1", "px-2", "rounded", "text-xs");
          row.classList.add("played-permanently");
          setTimeout(() => {
            copyButton.textContent = originalText;
            copyButton.classList.remove("bg-yellow-500", "text-black");
            copyButton.classList.add(...originalClasses);
          }, 1500);
        }).catch(() => {
          alert("Failed to URL to clipboard.");
        });
      });
      td.appendChild(copyButton);
      row.appendChild(td);

      fragment.appendChild(row);
    });
    playlistTableBody.appendChild(fragment);
    updateStatus();
  }

  function applyFilters() {
    const searchTerm = searchInput.value.toLowerCase();
    const groupTerm = groupFilterInput.value.toLowerCase();
    const countryVal = countryFilter.value;

    visibleChannels = allChannels.filter(channel => {
      const nameMatch = searchTerm ? channel.name.toLowerCase().includes(searchTerm) : true;
      const groupMatch = groupTerm ? channel.groupTitle.toLowerCase().includes(groupTerm) : true;
      let countryMatch = true;

      if (countryVal === "BLANK") {
        countryMatch = !channel.tvgId.match(/([A-Za-z]{2})$/);
      } else if (countryVal) {
        const match = channel.tvgId.match(/([A-Za-z]{2})$/);
        countryMatch = match && match[1].toUpperCase() === countryVal.toUpperCase();
      }

      return nameMatch && groupMatch && countryMatch;
    });

    renderTable(visibleChannels);
    updateStatus();
  }

  function updateGroupSuggestions() {
    const groupSet = new Set();
    allChannels.forEach(channel => {
      if (channel.groupTitle) groupSet.add(channel.groupTitle);
    });

    const dataList = document.getElementById("group-suggestions");
    dataList.innerHTML = "";
    groupSet.forEach(group => {
      const option = document.createElement("option");
      option.value = group;
      dataList.appendChild(option);
    });
  }

  function populateCountryDropdown() {
    countryFilter.innerHTML = '<option value="">All</option><option value="BLANK">Blank</option>';
    const countrySet = new Set();
    allChannels.forEach(channel => {
      const match = channel.tvgId && channel.tvgId.match(/([A-Za-z]{2})$/);
      if (match) countrySet.add(match[1].toUpperCase());
    });
    Array.from(countrySet).sort().forEach(code => {
      const opt = document.createElement("option");
      opt.value = code;
      opt.textContent = code;
      countryFilter.appendChild(opt);
    });
  }


 let undoTimeoutId = null;
  let pendingActions = 0;

  function showWaitOnUndoButton() {
    pendingActions++;
    undoButton.textContent = "WAIT...";
    undoButton.classList.add("bg-black");
    undoButton.classList.remove("bg-yellow-500", "hover:bg-yellow-700");
    if (undoTimeoutId) clearTimeout(undoTimeoutId);
    // Fallback to reset after 10 seconds if process hangs
    undoTimeoutId = setTimeout(() => {
      checkPendingActions();
    }, 10_000);
  }

  function resetUndoButton() {
    pendingActions = Math.max(0, pendingActions - 1);
    if (pendingActions === 0) {
      undoButton.textContent = "Undo";
      undoButton.classList.remove("bg-black");
      undoButton.classList.add("bg-yellow-500", "hover:bg-yellow-700");
      if (undoTimeoutId) {
        clearTimeout(undoTimeoutId);
        undoTimeoutId = null;
      }
    }
  }

  function checkPendingActions() {
    // This is a fallback. In a real application, you'd check for active processes.
    // For this simple case, we'll assume if no explicit pending actions, it's safe to reset.
    if (pendingActions === 0) {
      resetUndoButton();
    } else {
      // If there are still pending actions according to our counter, check again later
      undoTimeoutId = setTimeout(checkPendingActions, 2000); // Check again in 2 seconds
    }
  }

  // Example usage in undo handler and other long actions, replace:
  // undoButton.textContent = "WAIT...";
  // undoButton.classList.add("bg-black");
  // With:
  // showWaitOnUndoButton();

  // And when action done, call:
  // resetUndoButton();
  
// Example modified Undo button handler:
  undoButton.addEventListener("click", () => {
    if (history.length > 1) {
      showWaitOnUndoButton();
      setTimeout(() => {
        const previousState = history.pop();
        allChannels = previousState.allChannels;
        deletedChannels = previousState.deletedChannels;
        editedChannels = allChannels.filter(c => c.edited).length;
        applyFilters();
        renderTable(visibleChannels);
        updateStatus();
        resetUndoButton();
      }, 0); // Use 0 timeout to allow UI update
    } else {
      alert("No previous state to undo.");
    }
  });

 

 // Replace other long actions' button style changes with same pattern

  function autosave() {
    undoButton.style.backgroundColor = "green";
    const originalText = undoButton.textContent;
    undoButton.textContent = "saved";
    setTimeout(() => {
      undoButton.style.backgroundColor = "";
      undoButton.textContent = originalText;
    }, 1000);
  }

 duplicatesButton.addEventListener("click", () => {
    if (!duplicatesActive) {
      showWaitOnUndoButton();
      const urlCounts = {};
      allChannels.forEach(ch => urlCounts[ch.url] = (urlCounts[ch.url] || 0) + 1);
      visibleChannels = allChannels.filter(ch => urlCounts[ch.url] > 1);
      renderTable(visibleChannels);
      duplicatesButton.textContent = "Show All";
      duplicatesActive = true;
      resetUndoButton();
    } else {
      showWaitOnUndoButton();
      visibleChannels = [...allChannels];
      renderTable(visibleChannels);
      duplicatesButton.textContent = "Dupes"; // Corrected text
      duplicatesActive = false;
      resetUndoButton();
    }
  });

  selectAllCheckbox.addEventListener("change", () => {
    visibleChannels.forEach(ch => ch.selected = selectAllCheckbox.checked);
    renderTable(visibleChannels);
    updateStatus();
  });

  searchInput.addEventListener("input", debounce(() => { showWaitOnUndoButton(); applyFilters(); resetUndoButton(); }, 300));
  groupFilterInput.addEventListener("input", debounce(() => { showWaitOnUndoButton(); applyFilters(); resetUndoButton(); }, 300));
  countryFilter.addEventListener("change", () => { showWaitOnUndoButton(); applyFilters(); resetUndoButton(); });
  

  // For "Selected" / "Delete (n)" button text changes:
  deleteSelectedButton.addEventListener("click", () => {
    if (!showingSelectedToDelete) {
      showWaitOnUndoButton();
      previousFilter = searchInput.value;
      const selectedChannels = allChannels.filter(c => c.selected);
      visibleChannels = selectedChannels;
      renderTable(visibleChannels);
      searchInput.value = "";
      updateStatus();
      deleteSelectedButton.textContent = `Delete (${selectedChannels.length})`;
      duplicatesButton.textContent = "Export Selected";
      duplicatesButton.onclick = () => {
        showWaitOnUndoButton();
        const m3uContent = exportM3UContent(selectedChannels);
        const filename = generateFilename("m3u");
        downloadFile(m3uContent, filename, 'audio/x-mpegurl');
        resetUndoButton();
      };
      document.getElementById("cancel-delete").classList.remove("hidden");
      showingSelectedToDelete = true;
      resetUndoButton();
    } else {
      showWaitOnUndoButton();
      saveState();
      const selectedVisible = visibleChannels.filter(c => c.selected);
      deletedChannels.push(...selectedVisible);
      selectedVisible.forEach(del => {
        const idx = allChannels.indexOf(del);
        if (idx > -1) allChannels.splice(idx, 1);
      });
      if (previousFilter) {
        searchInput.value = previousFilter;
        applyFilters();
      } else {
        visibleChannels = [...allChannels];
        renderTable(visibleChannels);
        updateGroupSuggestions();
      }
      updateStatus();
      deleteSelectedButton.textContent = "Selected";
      duplicatesButton.textContent = "Dupes"; // Corrected text
      duplicatesButton.onclick = null;
      duplicatesButton.addEventListener("click", () => { // Re-add original duplicates button listener
          if (!duplicatesActive) {
            showWaitOnUndoButton();
            const urlCounts = {};
            allChannels.forEach(ch => urlCounts[ch.url] = (urlCounts[ch.url] || 0) + 1);
            visibleChannels = allChannels.filter(ch => urlCounts[ch.url] > 1);
            renderTable(visibleChannels);
            duplicatesButton.textContent = "Show All";
            duplicatesActive = true;
            resetUndoButton();
          } else {
            showWaitOnUndoButton();
            visibleChannels = [...allChannels];
            renderTable(visibleChannels);
            duplicatesButton.textContent = "Dupes"; // Corrected text
            duplicatesActive = false;
            resetUndoButton();
          }
        });
      showingSelectedToDelete = false;
      previousFilter = null;
      document.getElementById("cancel-delete").classList.add("hidden");
      resetUndoButton();
    }
  });
// Cancel delete resets UI text and state
  document.getElementById("cancel-delete").addEventListener("click", () => {
    showWaitOnUndoButton();
    visibleChannels = [...allChannels];
    renderTable(visibleChannels);
    updateStatus();
    deleteSelectedButton.textContent = "Selected";
    duplicatesActive = false;
    duplicatesButton.textContent = "Dupes"; // Corrected text
    duplicatesButton.onclick = null;
    duplicatesButton.addEventListener("click", () => { // Re-add original duplicates button listener
      if (!duplicatesActive) {
        showWaitOnUndoButton();
        const urlCounts = {};
        allChannels.forEach(ch => urlCounts[ch.url] = (urlCounts[ch.url] || 0) + 1);
        visibleChannels = allChannels.filter(ch => urlCounts[ch.url] > 1);
        renderTable(visibleChannels);
        duplicatesButton.textContent = "Show All";
        duplicatesActive = true;
        resetUndoButton();
      } else {
        showWaitOnUndoButton();
        visibleChannels = [...allChannels];
        renderTable(visibleChannels);
        duplicatesButton.textContent = "Dupes"; // Corrected text
        duplicatesActive = false;
        resetUndoButton();
      }
    });
    showingSelectedToDelete = false;
    previousFilter = null;
    document.getElementById("cancel-delete").classList.add("hidden");
    resetUndoButton();
  });

  // The rest of your JS (renderTable, playback, filters etc) remain unchanged except small integration fixes as noted earlier.

 function exportM3UContent(channels) {
    let m3uContent = "#EXTM3U\n";
    channels.forEach(channel => {
      m3uContent += `#EXTINF:-1 tvg-id="${channel.tvgId}" tvg-logo="${channel.tvgLogo}" group-title="${channel.groupTitle}",${channel.name}\n${channel.url}\n`;
    });
    return m3uContent;
  }

  function generateFilename(ext) {
    return currentFile ? currentFile.name.replace(/\.[^/.]+$/, "") + "." + ext : "playlist." + ext;
  }

  exportM3uButton.addEventListener("click", () => {
    if (allChannels.length > 0) {
      const m3uContent = exportM3UContent(allChannels);
      const filename = generateFilename("m3u");
      downloadFile(m3uContent, filename, "audio/x-mpegurl");
    } else {
      alert("No channels to export.");
    }
  });

 // Initial call to render empty table and update status
  renderTable(visibleChannels);
  updateStatus();
</script>
</body>
</html>
